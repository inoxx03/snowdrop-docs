=== Blog publication

=== Spring Boot + OpenTracing
28th of May 2018 by geoand

**Tags** : Spring Boot, OpenTracing, Distributed Tracing

**Description** : Getting started with Spring Boot applications instrumented with OpenTracing in order to get tracing insights with minimal developer effort.

==== Introduction

In a microservice topology, where an incoming HTTP call to the cluster could end up calling a host of other services, getting insights on the interactions of the individual services and performing debugging becomes complicated.

Distributed tracing gives developers and operators the ability to gain insights on the potentially complex interactions between microservices by painting a picture of what they look like in a graph form.

In it's most basic form, distributed tracing is implemented by having each microservice send special metadata to a collector (like link:https://www.jaegertracing.io[Jaeger], link:https://zipkin.io/[Zipkin]). 
The metadata usually consists of information (start time, end time, component) about the requests and operations performed when handling a external request.
For the collector to be able to construct a graph from the services / operations involved in handling a request, the calls that correspond to the handling of a single HTTP request need to have a piece of information that is unique to them.
Such uniqueness is accomplished by having the first microservice that handles the request create a request id and all subsequent microservices preserve that id in the metadata they send to the collector.

==== General Distributed Tracing prerequisites

The microservices deployed to the cluster need to be properly instrumented.

At the very least, instrumentation consists of propagating the proper HTTP headers when making requests between microservices. There are two options here:

* Manual instrumentation where the developer of each service needs to take care to propagate the HTTP headers to all downstream calls

* Use a library to automatically perform the instrumentation

The reason each application in the cluster needs to be instrumented for Distributed Tracing, is that in order to properly determine the relation between services (which service called which - or more formally what the nodes of the call DAG are), special metadata needs to propagated through each HTTP call, from the beginning of the life cycle of an incoming to request to the moment that the request is served to the external client.


===== Manual vs Automatic instrumentation

Manual instrumentation has the advantage that no extra dependencies need to be packaged with the code in order to get proper instrumentation to work. However it places the burden passing the necessary HTTP headers squarely on the developers shoulders. This can potentially make the code that performs service to service HTTP calls look ugly while more importantly incurring a high probability of such manual instrumentation being forgotten when a developer implements it, or tracing-specific bugs being introduced.

Automatic instrumentation means that the developer need not worry about passing the necessary tracing HTTP headers in every service call, since the library that performs the instrumentation takes care of such operations. It does mean however that an extra library needs to be packaged with the application to have tracing working properly.

==== Getting started

The first thing that needs to be done is to stand up a tracing collector locally. In this guide we will be using Jaeger which can be started very easily in dev mode using the following command (make sure you have docker installed)

[source,bash]
----
docker run -d -e \
  COLLECTOR_ZIPKIN_HTTP_PORT=9411 \
  -p 5775:5775/udp \
  -p 6831:6831/udp \
  -p 6832:6832/udp \
  -p 5778:5778 \
  -p 16686:16686 \
  -p 14268:14268 \
  -p 9411:9411 \
  jaegertracing/all-in-one:latest
----

Of the ports mentioned in the previous command, two are of particular interest, port `14268` which will be used to collect the traces from our microservices and port `16686` which is where we can view Jaeger's UI. 
By navigate to `http://localhost:16686` you'll see that there are no traces yet available, as is depicted in the following image.

image::images/dt-no-service.jpg


==== Info dump

https://github.com/snowdrop/cloud-native-frontend

https://github.com/snowdrop/cloud-native-backend

https://github.com/opentracing-contrib/java-spring-cloud

[source,xml]
----
<dependency>
    <groupId>io.opentracing.contrib</groupId>
    <artifactId>opentracing-spring-cloud-starter-jaeger</artifactId>
    <version>0.1.13</version>
</dependency>
----

'''

28th of May 2018 by Developer

**Tags** : Spring Boot, Cloud Native Development

**Description** : Lorum ipsum dolor ipset this site is real and it continues to grow.
Lorum ipsum dolor ipset this site is real and it continues to grow.

Lorum ipsum dolor ipset this site is real and it continues to grow.

Formating info is available https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/#horizontal-rules-and-page-breaks[here]

'''

=== New site is live!
/Snowdrop Developer - 2018-05-22/

Welcome to Snowdrop! We're glad you're here. Lorum ipsum dolor ipset this site is real and it continues to grow.

I have no idea how this is going to look. Let's try it out!

'''
